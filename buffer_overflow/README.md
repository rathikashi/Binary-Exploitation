## Buffer Overflows

1. A nice explanatinon of Buffer overflows and at attack can be found here: [Buffer overflow attacks explained](https://www.coengoedegebure.com/buffer-overflow-attacks-explained/)
2. Open the C program in a code editor (I use VSCode). 
3. The vulnerable code here is the `vuln()` function which allocates a buffer of size 16 and uses the `gets` function which does not perform bounds checking. 
4. As a result of this, a user can potentially write in more data (> 16) and cause the function to overwrite variables, execute other malicious functions.
5. In our program, we aim to overwrite the return address of the `vuln()` function and call the `secret()` function. 
6. The executable has been compiled as follows:
```
gcc -fno-stack-protector -z execstack -no-pie buf_of.c -o buf_of
```
7. Analyze the executable created as follows (you may need to install [checksec.sh](https://medium.com/@slimm609/checksec-d4131dff0fca)):
```
checksec --file=buf_of
```
8. Analyze the executable using ```file buf_of```.
9. The executable is 64bits in little endian format, with no stack protectors and no address randomization. 
10. Run the executable and see how many letters you can enter until the program seg faults:
```
./buf_of 
AAAAAAAAAAAAAAAAA
```
11. Open the executable in Ghidra. Go to the `vuln()` function and observe the offset of the buffer from the return address.
12. Look at the address of the `secret()` function.
13. On the shell, open up the executable with `pwndbg` or `gdb`.
14. Use the `disass vuln` command to look at the assembly code for the `vuln()` function. 
15. Use breakpoints in the code to analyze the stack right before and after the `gets()` function. 
16. Create the exploit: Notice that to reach the return address, we need 24 A's, this can be observed from 11 or from the `pwndbg` analysis. 
17. The final exploit is:
```
python2 -c "print 'A'*24 + '\x5a\x11\x40\x00\x00\x00\x00\x00'" > payload
```
18. The address above is the address of the `secret()` function in little-endian format. 
19. I have used a python2 script since addresses in hex are converted into random strings on bash and cannot be sent as input from the shell. 
20. Run the executable using the payload as input. 
21. Voila! You have successfully redirected execution and reached the secret function. 
22. You can write the same exploit using `pwntools` as seen in the `buf_of_exploit.py` file. 
23. Run the file as follows: ``` python3 buf_of_exploit.py ```. 
